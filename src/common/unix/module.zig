const std = @import("std");
const libc = std.c;

pub const ModuleError = error{
    NotFound,
    UndefinedSymbol,
};

extern "c" fn dlerror() ?[*:0]const u8;

pub inline fn loadPosixModule(module_path: [*:0]const u8) ?*anyopaque {
    return libc.dlopen(module_path, .{ .LAZY = true });
}

/// Returns a pointer to the error message generated by *loadPosixModule*
/// if it can't find any error and empty string is returned.
pub inline fn moduleErrorMsg() [*:0]const u8 {
    return if (dlerror()) |err| err else "";
}

pub inline fn freePosixModule(module_handle: *anyopaque) void {
    _ = libc.dlclose(module_handle);
}

pub inline fn moduleSymbol(module_handle: *anyopaque, symbol_name: [*:0]const u8) ?*anyopaque {
    return libc.dlsym(module_handle, symbol_name);
}

test "Loading and unloading shared objects" {
    const testing = std.testing;
    const module = loadPosixModule("libz.so.1");
    try testing.expect(@intFromPtr(module) != 0);
    const symbol = moduleSymbol(module.?, "compress");
    try testing.expect(@intFromPtr(symbol) != 0);
    freePosixModule(module.?);
}
